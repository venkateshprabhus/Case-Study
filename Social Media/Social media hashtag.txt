DynamoDB Table:
Table name: Hashtags
Partition key: Post_text (S)

Lambda:
To save: HashtagProcessor

API Gateway:
Name:Hashtagpost 
Routes: /POST
Route path: /post
API Type: HTTP
Integration: Lambda function

Streamlit application: 
=======================
import streamlit as st
import requests

api_post_url = "https://2nze9y2sra.execute-api.ap-south-1.amazonaws.com/prod/post"
api_get_url = "https://2nze9y2sra.execute-api.ap-south-1.amazonaws.com/prod/get"

st.title("Compose and Publish Your Post")

Post_text = st.text_area("Write your post and add hashtags (e.g., 'Your post text #hashtag1 #hashtag2'):", height=150)

# Button to post hashtags
if st.button("Publish"):
    if Post_text:
        response = requests.post(api_post_url, json={"Post_text": Post_text})
        st.write(f"Response Status Code: {response.status_code}")
        st.write(f"Response Body: {response.text}")
        if response.status_code == 200:
            st.success("Post published successfully!")
        else:
            st.error("Failed to publish post.")
    else:
        st.error("Text cannot be empty.")

# Button to get trending hashtags
if st.button("Get Trending Hashtags"):
    response = requests.get(api_get_url)
    if response.status_code == 200:
        trending_hashtags = response.json().get('trending_hashtags', [])
        if trending_hashtags:
            st.write("Trending Hashtags:")
            for hashtag, count in trending_hashtags:
                st.write(f"#{hashtag} - {count} times")
        else:
            st.write("No trending hashtags.")
    else:
        st.error("Failed to retrieve trending hashtags.")


Save data lambda function
=========================
import json
import boto3
from botocore.exceptions import ClientError

# Initialize DynamoDB resource
dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('Hashtags')

def lambda_handler(event, context):
    # Parse the incoming event data
    body = json.loads(event['body'])
    Post_text = body.get('Post_text')


    # Extract hashtags and the cleaned post text
    parts = Post_text.split()
    Hashtag = [part for part in parts if part.startswith('#')]
    cleaned_post_text = ' '.join([part for part in parts if not part.startswith('#')])

    if not Hashtag:
        return {
            'statusCode': 400,
            'body': json.dumps('At least one hashtag is required.')
        }

    # Store the hashtags and cleaned post text in DynamoDB
    try:
        response = table.put_item(
            Item={
                'Post_text': Post_text,
                'Cleaned_Post_text': cleaned_post_text,
                'Hashtag': ' '.join(Hashtag)  # Save hashtags as a space-separated string
            }
        )
        return {
            'statusCode': 200,
            'body': json.dumps('Post text and hashtags successfully stored.')
        }
    except ClientError as e:
        return {
            'statusCode': 500,
            'body': json.dumps(f'Error storing data: {e.response["Error"]["Message"]}')
        }


Analyse Hashtag
===================
import json
import boto3
from collections import Counter

# Initialize DynamoDB client
dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('Hashtags')

def lambda_handler(event, context):
    try:
        # Scan the DynamoDB table to get all posts
        response = table.scan()
        items = response.get('Items', [])

        # Collect hashtags from all posts
        hashtags = []
        for item in items:
            hashtags.extend(item.get('Hashtags', []))

        # Count hashtag occurrences
        hashtag_counts = Counter(hashtags)
        # Split the comma-separated string into a list of hashtags
        hashtags.extend([hashtag.strip() for hashtag in hashtags_string.split(',') if hashtag.strip()])

        # Identify top trending hashtags
        trending_hashtags = hashtag_counts.most_common(10)  # Get top 10 hashtags

    except Exception as e:
        print(e)
        return {
            "statusCode": 500,
            "body": json.dumps({"message": "Failed to analyze hashtags."})
        }

    return {
        "statusCode": 200,
        "body": json.dumps({"trending_hashtags": trending_hashtags})
    }









###Command with PostID

import streamlit as st
import requests
import uuid

api_base_url = "https://2nze9y2sra.execute-api.ap-south-1.amazonaws.com/prod/post"

st.title("Compose and Publish Your Post")

Post_Text = st.text_area("Write your post and add hashtags (e.g., 'Your post text #hashtag1 #hashtag2'):", height=150)

if st.button("Publish"):
    if Post_Text:
        # Generate a UUID for the post
        PostId = str(uuid.uuid4())
        
        # Prepare the payload with UUID and post text
        payload = {
            "PostId": PostId,
            "Post_Text": Post_Text
        }
        
        # Send the request to the API
        response = requests.post(api_base_url, json=payload)
        
        # Display response details
        st.write(f"Response Status Code: {response.status_code}")
        st.write(f"Response Body: {response.text}")
        
        if response.status_code == 200:
            st.success("Post published successfully!")
        else:
            st.error("Failed to publish post.")
    else:
        st.error("Text cannot be empty.")





import json
import boto3
from botocore.exceptions import ClientError

# Initialize DynamoDB resource
dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('Hashtags')

def lambda_handler(event, context):
    # Parse the incoming event data
    body = json.loads(event['body'])
    post_text = body.get('post_text')
    PostId = body.get('PostId')  # Extract post_id from the request body

    if not PostId:
        return {
            'statusCode': 400,
            'body': json.dumps('Post ID is required.')
        }

    # Extract hashtags and the cleaned post text
    parts = post_text.split()
    hashtags = [part for part in parts if part.startswith('#')]
    cleaned_post_text = ' '.join([part for part in parts if not part.startswith('#')])

    if not hashtags:
        return {
            'statusCode': 400,
            'body': json.dumps('At least one hashtag is required.')
        }

    # Store the hashtags and cleaned post text in DynamoDB
    try:
        response = table.put_item(
            Item={
                'PostId': PostId,  # Include the post_id in the DynamoDB item
                'post_text': cleaned_post_text,
                'hashtags': ' '.join(hashtags)  # Save hashtags as a space-separated string
            }
        )
        return {
            'statusCode': 200,
            'body': json.dumps('Post text and hashtags successfully stored.')
        }
    except ClientError as e:
        return {
            'statusCode': 500,
            'body': json.dumps(f'Error storing data: {e.response["Error"]["Message"]}')
        }





